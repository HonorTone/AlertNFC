/****************************************************************************
 *
 * @file	main.c
 * @brief	This is port sample program for S1C17M01/W22_W23 demonstration.
 *
 * @par		Copyright:
 *			Copyright (C) SEIKO EPSON CORPORATION 2013. All rights reserved.
 *
 * @warning -
 *
 * @par		History:
 *			- 10/04/2013    1.00
 *				- First revision.
 *
 ***************************************************************************/
/****************************************************************************
 * @mainpage	S1C17M01/W22_W23 Port
 *
 * @section		intro Introduction
 * The sample code set P01 in the output and set P02 to the input.
 * Interrupt is generated by edge of P02.
 *
 * @subsection	step1	Step 1: Start OSC1.
 *						Initialize and start OSC1.
 * @subsection	step2	Step 2: Initialize P01.
 *						P01 set to the output.
 *						P01 set the interrupt.
 * @subsection	step3	Step 3: Initialize P02.
 *						P02 set to the input.
 *						P02 set the interrupt.
 * @subsection	step4	Step 4: The setting of the interrupt of P02 set.
 *						It set that interrupt generate from LOW by HIGH.
 * @subsection	step5	Step 5: P01 set to LOW or HIGH.
 *						The interrupt of P02 is generated.
 *						It confirm that P02 is HIGH.
 * @subsection	step6	Step 6: The setting of the interrupt of P02 set.
 *						It set that interrupt generate from HIGH by LOW.
 * @subsection	step7	Step 7: P01 set to HIGH or LOW.
 *						The interrupt of P02 is generated.
 *						It confirm that P02 is LOW.
 *
 * @section		install Installation
 * Start the IDE and import the "s1c17m01_w22_w23_port" project.
 *
 ***************************************************************************/

#include <string.h>
#include <stdio.h>
#include <init.h>
#include <clg.h>
#include <port.h>
#include "lcd4a.h"
#include "lcd.h"
#include "main.h"
#include "i2c_mst.h"
#include "I2C.h"
#include "t16_ch0.h"
#include <rfc.h>
#include <uart.h>
#include <rtca.h>
#include "eeprom.h"
#include <pwg2.h>

/* --- function declaration --- */
unsigned long RfcCount = 0;
unsigned int Seconds;
//unsigned long RfcTempVal = 0;
int main(void);

uchar dispAddData[20]={0x5b,0x5c,0x6a,0x6b,0x63,0X6C,0x6d};
uchar dispDelData[20]={0x5b,0x5c,0x6a,0x6b,0x63,0X6C,0x6d};
uchar runEn=0;
//uchar alarmEn=1;
uchar TempRhDispEn=1;
uchar timeDispEn=0;
uchar dispEn=1;
uchar startKeyRressState=0;
uchar commByte=0;
uint intervTime=0;
uchar fechDataFlag=0;
uint dispIntervTime=2;
uint hiTBinTrpot=0;
uint hiFuncCount=0;
uint hiFuncLimit=0;
uint lowTBinTrpot=0;
uint lowFuncCount=0;
uint lowFuncLimit=0;
uchar scanKeyEn=1;
volatile uchar hiTempTrigl=0;
volatile uchar lowTempTrigl=0;
uchar stopStatus=0;
uchar dispSw=1;
uchar statusByte=0;
/****************************************************************************
 * main function.
 *
 * @brief	First, initialize port.
 *			Second, P02 set that interrupt generate from LOW by HIGH.
 *			Third, P01 set to LOW or HIGH.
 * 			Next, P02 set that interrupt generate from HIGH by LOW.
 *			Then, P01 set to HIGH or LOW.
 *
 * @retval	STATUS_OK	Success.
 * @retval	STATUS_NG	Failed.
 ***************************************************************************/
int main(void)
{
	//volatile unsigned char outData;
	//volatile unsigned char inData;
	uint i=0;
	unsigned long alarmTimeHi=0;
	unsigned long alarmTimeLow=0;
	unsigned long stopTime=0;
	unsigned long startTime=0;
	uchar commByte=0;
	uchar msgCnt=0;
	uchar i2cRevDate[6]={0};
	uchar i2cSendDate[3]={0};
	uchar eepwite[4]={20,21,22,25};
	uchar eepread[40]={0,0,0,0,0,0,0,0};
    uchar tem=0;
	//int modeNormal       = 0xFFFF;
	//int modeEconomy      = 0xFFFF;
	int modeSuperEconomy = 0xFFFF;
	//int modeAuto         = 0xFFFF;
	int status;
	long tempData=0;
	float fltData=0;
	float fltDataRh=0;
	int result = STATUS_NG;


	/* <<< Port demonstration start >>> */


	/// Initialize and start OSC1.
	startClgOSC1();									// start OSC1.
	//startClgOSC3();									// start OSC3.
	//startClgIOSC();
	/*
	status = switchClgSystemClockOSC1();			// The system clock is set in OSC3.
	if ( status == STATUS_NG ) {
		return STATUS_NG;
	}
	*/
	//stopClgIOSC();									// stop IOSC.

	/// Initialize LCD8B.
	lcdInit();

    /// Initialize I2C.
    while( STATUS_NG == initI2cMst() );

    /// I2C Start.
    startI2cMst();
    IIC_Init();
    //status = initT16Ch0();
    /*if ( status == STATUS_NG ) {
    	return STATUS_OK;
    }*/
    //presetT16Ch0Count( 10 );//10ms
    //startT16Ch0();

    /// Initialize RFC.
    if ( STATUS_NG == initRfc() ) {
        return STATUS_NG;
    }

    /// Start Rfc.
    startRfc();

    rtc_initSet();
    /// Initialize Port.
    initPort();
    /*/// Initialize UART.
    if ( STATUS_NG == initUart() ) {
    	asm("brk");
    	return STATUS_NG;
    }

    /// UART Start.
    startUart();*/
    /// P42 set to the output.
    //initPortOutputP1x( PORT_NO_PX1 );
    /// P42 set the interrupt.
    //disablePortIntP1x( PORT_NO_PX1 );
    //setPortOutputP1x( PORT_NO_PX1, PORT_DATA_HIGH );
	/// start LCD8B clock.
    setLcdDispMode(LCD_DISP_NORMAL);

    /*
    timeCount=0;
    rtcaIntCount1Sec=0;
    enableRtca1SecTimer();							// Enable 1 sec timer.
    startRtca();

    eepromWriteDefaut();
    eepromReadBytes(EE_LOWBIN_TEM_TRIP_POINT,eepread,2);
    //EE_WriteOneByte(0,eepwite,4);
    //EE_ReadOneByte(0,eepread,4);
    intervTime=eepread[1];
    intervTime<<=8;
    intervTime+=eepread[0];//得到间隔时间
    while(1)
    {

    	SHTW2ReadData(i2cRevDate,6);
    	    							tempData=i2cRevDate[3];//先获得温度高字节
    	    							tempData<<=8;
    	    							tempData+=i2cRevDate[4];//加上温度低字节
    	    							fltData=-45+(175*(float)tempData/65536);
    	    							dispDigital(fltData,2);
    	    							delay_ms(500);


    	setLcdDispMode(LCD_ALL_ON);

    	delay_ms(10000);
    	//setPortOutputP1x( PORT_NO_PX1, PORT_DATA_LOW );
    	setLcdDispMode(LCD_ALL_OFF);
    	delay_ms(10000);


    }
   */

	timeCount=0;
	rtcaIntCount1Sec=0;
	enableRtca1SecTimer();							// Enable 1 sec timer.
	startRtca();
	//eepromWriteDefaut();
	//eepwite[0]=0x10;
	//eepromWriteOneByOne(EE_COMMAND_BYTE,eepwite,1);//Command Byte
	//eepromWriteInit(10,0xff,4);
	eepwite[0]=0xff;eepwite[1]=0xff;eepwite[2]=0xff;eepwite[3]=0xff;
	eepromWriteOneByOne(EE_UNIT_START_TIME,eepwite,4);//Unit Start Time Stamp
	eepwite[0]=0xff;eepwite[1]=0xff;eepwite[2]=0xff;eepwite[3]=0xff;
	eepromWriteOneByOne(EE_UNIT_STOP_TIME,eepwite,4);//Unit Start Time Stamp
	eepwite[0]=0xff;eepwite[1]=0xff;eepwite[2]=0xff;eepwite[3]=0xff;
	eepromWriteOneByOne(EE_HIGH_ALARM_TIME,eepwite,4);//Unit Start Time Stamp
	eepwite[0]=0xff;eepwite[1]=0xff;eepwite[2]=0xff;eepwite[3]=0xff;
	eepromWriteOneByOne(EE_LOW_ALARM_TIME,eepwite,4);//Unit Start Time Stamp

	while( 1 )
	{

			/// Set LCD Normal Display
			//LCD4DSP_DSPC = (LCD4DSP_DSPC & 0xfc) | 1;
		    //onLcd8bReg();//显示全闪
		    //LCD8DSP_DSPC = (LCD8DSP_DSPC & 0xfc) | 2;
			//delay_ms(500);
			//LCD8DSP_DSPC = (LCD8DSP_DSPC & 0xfc) | 3;

		    /// Run RFC and get measurement counter.
            /*
		    RfcCount = 0;
			status = runRfcConvertingOperation( (unsigned long)0x00fc0000 , &RfcCount );
			if ( status == RFC_STS_CONV_SEN_A )
			{
				result = STATUS_OK;
				tem=1;
			}
			else
			{
				result = STATUS_NG;
				tem=0;
			}
            */
            /*
		    //asm ( "slp" );
			//asm ( "nop" );
		    setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );//使能I2C通道
		    if(timeCount==0)//LED闪烁
		    {
		    	timeCount=100;
		    	if(tem==0)
		    	{
			        setPortOutputP4x( PORT_NO_PX2, PORT_DATA_HIGH );
			        SHTW2ReadData(i2cRevDate,6);
			        tempData=i2cRevDate[0];//先获得湿度高字节
			        tempData<<=8;
			        tempData+=i2cRevDate[1];//加上湿度低字节
			        fltData=100*(float)tempData/65536;
			        dispDigital(fltData,1);
			        tem=1;
		    	}
		    	else if(tem==1)
		    	{
			        setPortOutputP4x( PORT_NO_PX2, PORT_DATA_LOW );
			        SHTW2ReadData(i2cRevDate,6);
			        tempData=i2cRevDate[3];//先获得温度高字节
			        tempData<<=8;
			        tempData+=i2cRevDate[4];//加上温度低字节
			        //fltData=(float)tempData/65536;
			        //fltData*=175;
			        //fltData-=45;
			        fltData=-45+(175*(float)tempData/65536);
			        dispDigital(fltData,2);
			        tem=0;
		    	}
		    }
            */

		    ///*
            /*
			if ( STATUS_NG == setPwg2ModeEconomy() ) {
							//asm("brk");
							break;
						}
		    modeEconomy = getPwg2Mode();
		    /// Set Normal mode.
			if ( STATUS_NG == setPwg2ModeNormal() ) {
				//asm("brk");
				//return STATUS_NG;
			}
			*/
			///*
			restop:
			modeSuperEconomy = getPwg2Mode();
			if(modeSuperEconomy!=5)//如果当前省电模式不是超省就切换到超省
			{
				status = switchClgSystemClockOSC1();
				stopClgIOSC();
				if ( STATUS_NG == setPwg2ModeSuperEconomy() ) {
					asm("nop");
					goto restop;
				}
			}

			// Get PWG2 mode.
			//modeSuperEconomy = getPwg2Mode();
			asm("halt");
			asm("nop");
            //*/
			//eepromWriteOneByOne(EE_MEASURE_INTERVAL,eepwite,2);
			//status = eepromReadBytes(38,eepread,4);
			//eepromReadBytes(EE_MEASURE_INTERVAL,eepread,2);
			//setPortOutputP4x( PORT_NO_PX3, PORT_DATA_LOW );
			///*
			if(key_start)//启动键
			{
				///*
				if ( STATUS_NG == setPwg2ModeAuto() ) {
				    //asm("brk");
					//break;
				}
				// Get PWG2 mode.
				//modeAuto = getPwg2Mode();

				startClgIOSC();
				status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
				//*/
				tem=getPortInputP1x(PORT_NO_PX0);//等待松开按键
			    if(tem==0)goto START_END;
			    key_start=0;

			    if(runEn==0)
			    {
			        eepromReadBytes(EE_COMMAND_BYTE,eepread,1);
			        commByte=eepread[0];
			        if(commByte&0x10)//看是否已配置,=0已配置，==1新的,还未配置
			        {
			        	setLcdDispMode(LCD_ALL_OFF);
			        	//setLcdDispMode(LCD_ALL_ON);
			        	setLcdDispMode(LCD_DISP_NORMAL);

			        	startKeyRressState=0;
			        	timeDispEn=0;
			        	dispSw=1;
			        	fechDataFlag=0;
			        	msgCnt=0;
			        	stopStatus=0;
			        	hiTempTrigl=0;
			        	lowTempTrigl=0;
			        }
			        else goto START_END;
			    }
			    if(!startKeyRressState)
			    {
			    	//startKeyRressState
			        //scanKeyEn=0;
                    /*
			    	SHTW2ReadData(i2cRevDate,6);
			    	tempData=i2cRevDate[3];//先获得温度高字节
			    	tempData<<=8;
			    	tempData+=i2cRevDate[4];//加上温度低字节
			    	fltData=-45+(175*(float)tempData/65536);
			    	dispDigital(fltData,2);
                    */


				    //eepromReadBytes(EE_COMMAND_BYTE,eepread,1);
				    //tem=eepread[0];

				    //if(!(commByte&(1<<COMMB_UNCONFIG)))//看是否已配置,=0已配置，==1未配置
			    	//if(commByte&0x10)//看是否已配置,=0已配置，==1未配置
				    {

				    	runEn=1;

				    	startKeyRressState=0;
				    	startTime=rtc_getSeconds();

				    	//timeCount=0xfff0;
				    	OnOffSingleDisp(0x14,1);//显示太阳图标

				    	eepwite[0]=startTime&0xff;eepwite[1]=(startTime>>8)&0xff;//低位在前,高位在后
				    	eepwite[2]=(startTime>>16)&0xff;eepwite[3]=(startTime>>24)&0xff;
				    	eepromWriteOneByOne(EE_UNIT_START_TIME,eepwite,4);//Unit Start Time Stamp

				    	eepwite[0]=commByte&0xEF;
				    	eepromWriteOneByOne(EE_COMMAND_BYTE,eepwite,1);//Command Byte

				    	eepwite[0]=0;eepwite[1]=0;
				    	eepromWriteOneByOne(EE_HIGHBIN_F_COUNTER,eepwite,2);//High Bin Function Counter

				    	eepwite[0]=lowFuncCount%256;eepwite[1]=lowFuncCount/256;
				    	eepromWriteOneByOne(EE_LOWBIN_F_COUNTER,eepwite,2);//Low Bin Function Counter

				    	eepwite[0]=0;
				    	eepromWriteOneByOne(EE_ALARM_STATUS,eepwite,1);//Alarm Status Byte

				    	eepromReadBytes(EE_STARTUP_DELAY,eepread,4);
				    	intervTime=eepread[3];
				    	intervTime<<=8;
				    	intervTime+=eepread[2];//得到间隔时间

				    	eepromReadBytes(EE_HIGHBIN_TEM_TRIP_POINT,eepread,22);
				    	hiTBinTrpot=eepread[1];
				    	hiTBinTrpot<<=8;
				    	hiTBinTrpot+=eepread[0];//得到高温报警点

				    	hiFuncCount=eepread[5];
				    	hiFuncCount<<=8;
				    	hiFuncCount+=eepread[4];//得到触发高温报警的计数器

				    	hiFuncLimit=eepread[9];
				    	hiFuncLimit<<=8;
				    	hiFuncLimit+=eepread[8];//得到高温报警触发极限值

				    	lowTBinTrpot=eepread[13];
				    	lowTBinTrpot<<=8;
				    	lowTBinTrpot+=eepread[12];//得到低温报警点

				    	lowFuncCount=eepread[17];
				    	lowFuncCount<<=8;
				    	lowFuncCount+=eepread[16];//得到触发低温报警的计数器

				    	lowFuncLimit=eepread[21];
				    	lowFuncLimit<<=8;
				    	lowFuncLimit+=eepread[20];//得到低温报警触发极限值
                        /*
					    eepromReadBytes(EE_MEASURE_INTERVAL,eepread,2);
					    intervTime=eepread[1];
					    intervTime<<=8;
					    intervTime+=eepread[0];//得到间隔时间

					    eepromReadBytes(EE_HIGHBIN_TEM_TRIP_POINT,eepread,2);
					    hiTBinTrpot=eepread[1];
					    hiTBinTrpot<<=8;
					    hiTBinTrpot+=eepread[0];//得到高温报警点
					    eepromReadBytes(EE_HIGHBIN_F_COUNTER,eepread,2);
					    hiFuncCount=eepread[1];
					    hiFuncCount<<=8;
					    hiFuncCount+=eepread[0];//得到触发高温报警的计数器
					    eepromReadBytes(EE_HIGH_FUNC_LIMIT,eepread,2);
					    hiFuncLimit=eepread[1];
					    hiFuncLimit<<=8;
					    hiFuncLimit+=eepread[0];//得到高温报警触发极限值

					    eepromReadBytes(EE_LOWBIN_TEM_TRIP_POINT,eepread,2);
					    lowTBinTrpot=eepread[1];
					    lowTBinTrpot<<=8;
					    lowTBinTrpot+=eepread[0];//得到低温报警点
					    //dispDigital(lowTBinTrpot,1);while(1);
					    eepromReadBytes(EE_LOWBIN_F_COUNTER,eepread,2);
					    lowFuncCount=eepread[1];
					    lowFuncCount<<=8;
					    lowFuncCount+=eepread[0];//得到触发低温报警的计数器
					    eepromReadBytes(EE_LOW_FUNC_LIMIT,eepread,2);
					    lowFuncLimit=eepread[1];
					    lowFuncLimit<<=8;
					    lowFuncLimit+=eepread[0];//得到低温报警触发极限值
					    */


				   }

			    }
			    else
			    {
			    	timeDispEn=1;//显示事件信息
			    	goto DISP_START;
			    }
			    START_END:
			}
			if(key_stop)//停止键
			{
				key_stop=0;
				///*
				if ( STATUS_NG == setPwg2ModeAuto() ) {
					//asm("brk");
					//break;
				}
				// Get PWG2 mode.
				//modeAuto = getPwg2Mode();

				startClgIOSC();
				status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
				//*/

				tem=getPortInputP1x(PORT_NO_PX1);//等待松开按键
				if(tem==0)goto STOP_END;
				if(stopStatus) goto STOP_END;//已按过停止键，按键不再有效


				if(runEn==1)//在有当设备运行过程中按键才有效
				{
					stopTime=rtc_getSeconds();
					//key_stop=0;
					stopStatus=1;
					runEn=0;
					OnOffSingleDisp(0x14,0);//关闭太阳图标
					OnOffSingleDisp(0x18,1);//显示停止图标
					timeDispEn=1;//显示停止时间有效

					eepwite[0]=stopTime&0xff;eepwite[1]=(stopTime>>8)&0xff;//低位在前,高位在后
					eepwite[2]=(stopTime>>16)&0xff;eepwite[3]=(stopTime>>24)&0xff;
					eepromWriteOneByOne(EE_UNIT_STOP_TIME,eepwite,4);//Unit Stop Time Stamp
					goto DISP_START;
				}


				STOP_END:
			}
			if(dispEn)
			{
				if(fechDataFlag==0)goto DISP_END;
                if(dispTimeCnt>=dispIntervTime)
                {
                	///*
                	if ( STATUS_NG == setPwg2ModeAuto() ) {
                		//asm("brk");
                		//break;
                	}
                	// Get PWG2 mode.
                	//modeAuto = getPwg2Mode();

                	startClgIOSC();
                	status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
                	//*/

                	DISP_START:
                	dispTimeCnt=0;
                	if(timeDispEn)
                	{
                		timeDispEn=0;
                		if(msgCnt==0)
                		{
                			disp_step0:
                		    if(stopStatus)
                		    {
                			    //stopKeyPressed=0;
                			    i=stopTime-startTime;
                			    dispRunTime(i);
                			    msgCnt++;
                		    }
                		    else goto disp_step1;

                		}
                		else if(msgCnt==1)
                		{
                			disp_step1:
                		    if(hiTempTrigl)
                		    {
                		        //stopKeyPressed=0;
                		        i=alarmTimeHi-startTime;
                		        dispRunTime(i);
                		        msgCnt++;
                		     }
                		     else goto disp_step2;

                		}
                		else if(msgCnt==2)
                		{
                			disp_step2:
                		    if(lowTempTrigl)
                		    {
                		        //stopKeyPressed=0;
                		        i=alarmTimeLow-startTime;
                		        dispRunTime(i);
                		        msgCnt++;
                		    }
                		    else
                		    {
                		    	msgCnt=0;
                		    	if((stopStatus)||(hiTempTrigl))//上面还有要显示的消息
                		    	{
                		    		goto disp_step0;
                		    	}

                		    }


                		}
                		if(msgCnt>=3)msgCnt=0;
                	}
                	else if(TempRhDispEn)
                    {
                		//dispDigital(fltData,2);
                		///*
                		if(dispSw)//显示温度
                		{
                			dispSw=0;
                			dispDigital(fltData,2);
                		}
                		else
                		{
                			dispSw=1;
                			dispDigital(fltDataRh,1);
                		}
                		//*/
                    }
                }
                DISP_END:
			}
			if(runEn)
			{


				if(timeCount>=intervTime)
				{
                    ///*
					if ( STATUS_NG == setPwg2ModeAuto() ) {
						//asm("brk");
						//break;
					}
					// Get PWG2 mode.
					//modeAuto = getPwg2Mode();

					startClgIOSC();
					status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
                    //*/

					timeCount=0;


					/*
					RfcCount = 0;
					status = runRfcConvertingOperation( (unsigned long)0x00FFD8F0 , &RfcCount );//耗时270ms
					if ( status == RFC_STS_CONV_SEN_A )
					{
						//RfcTempVal=RfcTempVal;
						fltData=getTemp(RfcCount);
						dispDigital(fltData,2);
						//delay_ms(5000);
					}
					*/
                    ///*
					SHTW2ReadData(i2cRevDate,6);
					tempData=i2cRevDate[0];//先获得湿度高字节
					tempData<<=8;
					tempData+=i2cRevDate[1];//加上湿度低字节
					fltDataRh=100*(float)tempData/65536;

					tempData=i2cRevDate[3];//先获得温度高字节
					tempData<<=8;
					tempData+=i2cRevDate[4];//加上温度低字节
					fltData=-45+(175*(float)tempData/65536);
					//*/

					fechDataFlag=1;
					if(fltData>hiTBinTrpot)
					{
						hiFuncCount++;

						if(hiFuncCount>=hiFuncLimit)
						{
						    alarmTimeHi=rtc_getSeconds();
						    OnOffSingleDisp(0x14,0);//关闭太阳图标
						    //OnOffSingleDisp(0x2B,1);//显示HI图标
						    OnOffSingleDisp(0x19,1);//显示对错图标
						    OnOffSingleDisp(0x20,1);//
						    OnOffSingleDisp(0x21,1);//
						    disp_H_L_Char(1);//显示H
						    hiTempTrigl=1;

						    i=statusByte|0x01;
						    eepwite[0]=i;
						    eepromWriteOneByOne(EE_ALARM_STATUS,eepwite,1);//Alarm Status Byte

						    eepwite[0]=hiFuncCount%256;eepwite[1]=hiFuncCount/256;
						    eepromWriteOneByOne(EE_HIGHBIN_F_COUNTER,eepwite,2);//High Bin Function Counter

						    //i=0;
						    eepwite[0]=alarmTimeHi&0xff;eepwite[1]=(alarmTimeHi>>8)&0xff;//低位在前,高位在后
						    eepwite[2]=(alarmTimeHi>>16)&0xff;eepwite[3]=(alarmTimeHi>>24)&0xff;
						    eepromWriteOneByOne(EE_HIGH_ALARM_TIME,eepwite,4);//High Alarm Time Stamp
						}
						//runEn=0;
					}
					if(fltData<lowTBinTrpot)
					{
						lowFuncCount++;
						if(lowFuncCount>=lowFuncLimit)
						{
						    alarmTimeLow=rtc_getSeconds();
						    OnOffSingleDisp(0x14,0);//关闭太阳图标
						    //OnOffSingleDisp(0x3B,1);//显示LOW图标
						    OnOffSingleDisp(0x19,1);//显示对错图标
						    OnOffSingleDisp(0x20,1);//
						    OnOffSingleDisp(0x21,1);//
						    disp_H_L_Char(0);//显示L
						    lowTempTrigl=1;
						    //runEn=0;

						    i=statusByte|0x04;;
						    eepwite[0]=i;
						    eepromWriteOneByOne(EE_ALARM_STATUS,eepwite,1);//Alarm Status Byte

						    eepwite[0]=lowFuncCount%256;eepwite[1]=lowFuncCount/256;
						    eepromWriteOneByOne(EE_LOWBIN_F_COUNTER,eepwite,2);//Low Bin Function Counter

						    eepwite[0]=alarmTimeLow&0xff;eepwite[1]=(alarmTimeLow>>8)&0xff;//低位在前,高位在后
						    eepwite[2]=(alarmTimeLow>>16)&0xff;eepwite[3]=(alarmTimeLow>>24)&0xff;
						    eepromWriteOneByOne(EE_LOW_ALARM_TIME,eepwite,4);//Low Alarm Time Stamp
						}
					}
					if((lowTempTrigl==1)&&(hiTempTrigl==1))
					{
						OnOffSingleDisp(0x18,1);//显示停止图标
						//OnOffSingleDisp(0x19,0);//关闭太阳图标
						OnOffSingleDisp(0x20,1);//显示停止图标
						OnOffSingleDisp(0x21,1);//显示停止图标

						stopTime=rtc_getSeconds();
						eepwite[0]=stopTime&0xff;eepwite[1]=(stopTime>>8)&0xff;//低位在前,高位在后
						eepwite[2]=(stopTime>>16)&0xff;eepwite[3]=(stopTime>>24)&0xff;
						eepromWriteOneByOne(EE_UNIT_STOP_TIME,eepwite,4);//Unit Stop Time Stamp
						runEn=0;
						stopStatus=1;
					}
				}



			}
            //*/

			/*
			//setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );
			//status = eepromWriteBytes(1,eepwite,1);
			eepromWriteOneByOne(38,eepwite,4);
			status = eepromReadBytes(38,eepread,4);
			setPortOutputP4x( PORT_NO_PX3, PORT_DATA_LOW );
			*/


			/*
			restop:
			modeSuperEconomy = getPwg2Mode();
			if(modeSuperEconomy!=5)
			{
				status = switchClgSystemClockOSC1();
				stopClgIOSC();
				if ( STATUS_NG == setPwg2ModeSuperEconomy() ) {
				    asm("nop");
				    goto restop;
				}
			}

			// Get PWG2 mode.
			//modeSuperEconomy = getPwg2Mode();
			asm("halt");
			asm("nop");



			//asm ( "slp" );
			//asm ( "nop" );
			//disableRtca1SecTimer();


		    if(timeCount>=5)
		    {
		    	timeCount=0;
		    	if ( STATUS_NG == setPwg2ModeAuto() ) {
		    		//asm("brk");
		    		//break;
		    	}
		    	// Get PWG2 mode.
		    	//modeAuto = getPwg2Mode();

		    	startClgIOSC();
		    	status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
		    	//timeCount=30000;
		    	//timeCount=500;

		        //RfcCount = 0;
		        //status = runRfcConvertingOperation( (unsigned long)0x00FFD8F0 , &RfcCount );//耗时270ms
		        //if ( status == RFC_STS_CONV_SEN_A )
		        //{
		    	//    //RfcTempVal=RfcTempVal;
		    	 //   fltData=getTemp(RfcCount);
		    	 //   dispDigital(fltData,2);
		        //}


		    	setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );
		    	SHTW2ReadData(i2cRevDate,6);
		    	tempData=i2cRevDate[3];//先获得温度高字节
		    	tempData<<=8;
		    	tempData+=i2cRevDate[4];//加上温度低字节
		    	fltData=-45+(175*(float)tempData/65536);
		    	dispDigital(fltData,2);
		    	setPortOutputP4x( PORT_NO_PX3, PORT_DATA_LOW );
		    }


			//delay_ms(100);
			*/


		    /*
		    //setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );
		    Seconds=rtc_getSeconds();

		    status = eepromWriteBytes(0,eepwite,4);
		    status = eepromReadBytes(0,eepread,4);
		    //SHTW2ReadData(i2cRevDate,6);
		    */


		    /*status = sendUartData( dispAddData, 7 );
		    	if ( status != STATUS_OK ) {
		    		asm("brk");
		    		return STATUS_NG;
		    	}*/
		/// Set LCD Normal Display

			//LCD8DSP_DSPC = (LCD8DSP_DSPC & 0xfc) | 1;
		    //SetLcd8bDisplay1Seg(LCD_SEG19,0,1);

			//delay_ms(500);

			//SetLcd8bDisplay1Seg(LCD_SEG19,0,0);*/

		    //LcdDisplayChar(dispAddData,7,NULL,0);
		    //SetLcd8bDisplay1Seg(LCD_5B_SEG,LCD_5B_COM,1);

		    //dispDigital(-138.1,1);

		    //setPortOutputP4x( PORT_NO_PX2, PORT_DATA_LOW );
			//delay_ms(500);

		    //while(timeCount>0);//10MS定时
/*
			i2cSendDate[0]=0X5C;i2cSendDate[1]=0X24;
			status = sendI2cMstData( ADDRES_SHTW2, i2cSendDate, 2 );
			if ( status != I2C_MST_STS_OK )
			{
				/// Stop I2C.
				stopI2cMst();
			}
			delay_ms(20);
			/// Receive data.
			status = receiveI2cMstData( ADDRES_SHTW2, i2cRevDate, 6 );

			/// Check on receive result.
			if ( status != I2C_MST_STS_OK )
			{
				/// Stop I2C.
				stopI2cMst();
			}
*/

	}

	return STATUS_OK;
}
void delay_ms(int time)
{
	int i,j;
	for(i=time;i>0;i--)
	{
		for(j=120;j>0;j--);
	}

}
void delay_us(int time)
{
	int i,j;
	for(i=time;i>0;i--)
	{
		for(j=1;j>0;j--);
	}

}
void cleanDateBuf(uchar *data,uchar len)
{
	int i;
	for(i=0;i<len;i++)
	{
		data[i]=0;
	}
}
