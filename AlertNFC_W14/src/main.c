/****************************************************************************
 *
 * @file	main.c
 * @brief	This is port sample program for S1C17M01/W22_W23 demonstration.
 *
 * @par		Copyright:
 *			Copyright (C) SEIKO EPSON CORPORATION 2013. All rights reserved.
 *
 * @warning -
 *
 * @par		History:
 *			- 10/04/2013    1.00
 *				- First revision.
 *
 ***************************************************************************/
/****************************************************************************
 * @mainpage	S1C17M01/W22_W23 Port
 *
 * @section		intro Introduction
 * The sample code set P01 in the output and set P02 to the input.
 * Interrupt is generated by edge of P02.
 *
 * @subsection	step1	Step 1: Start OSC1.
 *						Initialize and start OSC1.
 * @subsection	step2	Step 2: Initialize P01.
 *						P01 set to the output.
 *						P01 set the interrupt.
 * @subsection	step3	Step 3: Initialize P02.
 *						P02 set to the input.
 *						P02 set the interrupt.
 * @subsection	step4	Step 4: The setting of the interrupt of P02 set.
 *						It set that interrupt generate from LOW by HIGH.
 * @subsection	step5	Step 5: P01 set to LOW or HIGH.
 *						The interrupt of P02 is generated.
 *						It confirm that P02 is HIGH.
 * @subsection	step6	Step 6: The setting of the interrupt of P02 set.
 *						It set that interrupt generate from HIGH by LOW.
 * @subsection	step7	Step 7: P01 set to HIGH or LOW.
 *						The interrupt of P02 is generated.
 *						It confirm that P02 is LOW.
 *
 * @section		install Installation
 * Start the IDE and import the "s1c17m01_w22_w23_port" project.
 *
 ***************************************************************************/

#include <string.h>
#include <stdio.h>
#include <init.h>
#include <clg.h>
#include <port.h>
#include "lcd8b.h"
#include "main.h"
#include "i2c_mst.h"
#include "t16_ch0.h"
#include <rfc.h>
#include <uart.h>
#include <rtca.h>
#include "eeprom.h"
#include <pwg2.h>

/* --- function declaration --- */
unsigned long RfcCount = 0;
unsigned int Seconds;
//unsigned long RfcTempVal = 0;
int main(void);

uchar dispAddData[20]={0x5b,0x5c,0x6a,0x6b,0x63,0X6C,0x6d};
uchar dispDelData[20]={0x5b,0x5c,0x6a,0x6b,0x63,0X6C,0x6d};
uchar runEn=0;
uchar commByte=0;
uint intervTime=0;
uint hiTBinTrpot=0;
uint hiFuncCount=0;
uint hiFuncLimit=0;
uint lowTBinTrpot=0;
uint lowFuncCount=0;
uint lowFuncLimit=0;

/****************************************************************************
 * main function.
 *
 * @brief	First, initialize port.
 *			Second, P02 set that interrupt generate from LOW by HIGH.
 *			Third, P01 set to LOW or HIGH.
 * 			Next, P02 set that interrupt generate from HIGH by LOW.
 *			Then, P01 set to HIGH or LOW.
 *
 * @retval	STATUS_OK	Success.
 * @retval	STATUS_NG	Failed.
 ***************************************************************************/
int main(void)
{
	//volatile unsigned char outData;
	//volatile unsigned char inData;
	uchar i2cRevDate[6]={0};
	uchar i2cSendDate[3]={0};
	uchar eepwite[4]={21,22,7,8};
	uchar eepread[8]={0,0,0,0,0,0,0,0};
    uchar tem=0;
	//int modeNormal       = 0xFFFF;
	//int modeEconomy      = 0xFFFF;
	int modeSuperEconomy = 0xFFFF;
	//int modeAuto         = 0xFFFF;
	int status;
	long tempData=0;
	float fltData=0;
	int result = STATUS_NG;


	/* <<< Port demonstration start >>> */


	/// Initialize and start OSC1.
	startClgOSC1();									// start OSC1.
	//startClgOSC3();									// start OSC3.
	//startClgIOSC();
	/*
	status = switchClgSystemClockOSC1();			// The system clock is set in OSC3.
	if ( status == STATUS_NG ) {
		return STATUS_NG;
	}
	*/
	//stopClgIOSC();									// stop IOSC.

	/// Initialize Port.
	initPort();

	/// Initialize LCD8B.
    initLcd8b();

    /// Initialize I2C.
    while( STATUS_NG == initI2cMst() );

    /// I2C Start.
    startI2cMst();

    //status = initT16Ch0();
    /*if ( status == STATUS_NG ) {
    	return STATUS_OK;
    }*/
    //presetT16Ch0Count( 10 );//10ms
    //startT16Ch0();

    /// Initialize RFC.
    if ( STATUS_NG == initRfc() ) {
        return STATUS_NG;
    }

    /// Start Rfc.
    startRfc();
    rtc_initSet();

    /*/// Initialize UART.
    if ( STATUS_NG == initUart() ) {
    	asm("brk");
    	return STATUS_NG;
    }

    /// UART Start.
    startUart();*/
    /// P42 set to the output.
    initPortOutputP4x( PORT_NO_PX2 );
    /// P42 set the interrupt.
    disablePortIntP4x( PORT_NO_PX2 );
	/// start LCD8B clock.
    ///*
    //eepromReadBytes(EE_MEASURE_INTERVAL,eepread,2);
    //intervTime=eepread[1];
    //intervTime<<=8;
    //intervTime+=eepread[0];
    StartLcd8bClock();
    onLcd8bReg();
    	timeCount=0;
    	rtcaIntCount1Sec=0;
    	enableRtca1SecTimer();							// Enable 1 sec timer.
    	startRtca();
    	LCD8DSP_DSPC = (LCD8DSP_DSPC & 0xfc) | 1;
    while(1)
        {
    	setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );
    						SHTW2ReadData(i2cRevDate,6);
    						tempData=i2cRevDate[3];//先获得温度高字节
    						tempData<<=8;
    						tempData+=i2cRevDate[4];//加上温度低字节
    						fltData=-45+(175*(float)tempData/65536);
    						dispDigital(fltData,2);
        	//setPortOutputP4x( PORT_NO_PX2, PORT_DATA_HIGH );
        	//delay_ms(1000);
        	//setPortOutputP4x( PORT_NO_PX2, PORT_DATA_LOW );
        	delay_ms(500);
        }

	StartLcd8bClock();
	//*/

	onLcd8bReg();
	timeCount=0;
	rtcaIntCount1Sec=0;
	enableRtca1SecTimer();							// Enable 1 sec timer.
	startRtca();
	//eepromWriteDefaut();
	while( 1 )
	{

		    /// Set LCD Normal Display
			LCD8DSP_DSPC = (LCD8DSP_DSPC & 0xfc) | 1;
		    //onLcd8bReg();//显示全闪
		    //LCD8DSP_DSPC = (LCD8DSP_DSPC & 0xfc) | 2;
			//delay_ms(500);
			//LCD8DSP_DSPC = (LCD8DSP_DSPC & 0xfc) | 3;

		    /// Run RFC and get measurement counter.
            /*
		    RfcCount = 0;
			status = runRfcConvertingOperation( (unsigned long)0x00fc0000 , &RfcCount );
			if ( status == RFC_STS_CONV_SEN_A )
			{
				result = STATUS_OK;
				tem=1;
			}
			else
			{
				result = STATUS_NG;
				tem=0;
			}
            */
            /*
		    //asm ( "slp" );
			//asm ( "nop" );
		    setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );//使能I2C通道
		    if(timeCount==0)//LED闪烁
		    {
		    	timeCount=100;
		    	if(tem==0)
		    	{
			        setPortOutputP4x( PORT_NO_PX2, PORT_DATA_HIGH );
			        SHTW2ReadData(i2cRevDate,6);
			        tempData=i2cRevDate[0];//先获得湿度高字节
			        tempData<<=8;
			        tempData+=i2cRevDate[1];//加上湿度低字节
			        fltData=100*(float)tempData/65536;
			        dispDigital(fltData,1);
			        tem=1;
		    	}
		    	else if(tem==1)
		    	{
			        setPortOutputP4x( PORT_NO_PX2, PORT_DATA_LOW );
			        SHTW2ReadData(i2cRevDate,6);
			        tempData=i2cRevDate[3];//先获得温度高字节
			        tempData<<=8;
			        tempData+=i2cRevDate[4];//加上温度低字节
			        //fltData=(float)tempData/65536;
			        //fltData*=175;
			        //fltData-=45;
			        fltData=-45+(175*(float)tempData/65536);
			        dispDigital(fltData,2);
			        tem=0;
		    	}
		    }
            */

		    ///*
            /*
			if ( STATUS_NG == setPwg2ModeEconomy() ) {
							//asm("brk");
							break;
						}
		    modeEconomy = getPwg2Mode();
		    /// Set Normal mode.
			if ( STATUS_NG == setPwg2ModeNormal() ) {
				//asm("brk");
				//return STATUS_NG;
			}
			*/
			/*
			restop:
			modeSuperEconomy = getPwg2Mode();
			if(modeSuperEconomy!=5)//如果当前省电模式不是超省就切换到超省
			{
				status = switchClgSystemClockOSC1();
				stopClgIOSC();
				if ( STATUS_NG == setPwg2ModeSuperEconomy() ) {
					asm("nop");
					goto restop;
				}
			}

			// Get PWG2 mode.
			//modeSuperEconomy = getPwg2Mode();
			asm("halt");
			asm("nop");
            */
			//eepromWriteOneByOne(EE_MEASURE_INTERVAL,eepwite,2);
			//status = eepromReadBytes(38,eepread,4);
			//eepromReadBytes(EE_MEASURE_INTERVAL,eepread,2);
			//setPortOutputP4x( PORT_NO_PX3, PORT_DATA_LOW );
			///*
			if(key_start)//启动键
			{
				tem=getPortInputP3x(PORT_NO_PX0);
			    if(tem==0)goto START_END;

			    key_start=0;
			    if(runEn==0)
			    {
                   /*
				   if ( STATUS_NG == setPwg2ModeAuto() ) {
				   	    //asm("brk");
				   		//break;
				    }
				    // Get PWG2 mode.
				    //modeAuto = getPwg2Mode();

				    startClgIOSC();
				    status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
                    */


				    timeCount=0;
				    OnOffSingleDisp(0x1A,1);//显示太阳图标

				    eepromReadBytes(EE_COMMAND_BYTE,eepread,1);
				    tem=eepread[0];
				    if(!(tem&(1<<COMMB_UNCONFIG)))//看是否已配置,=0已配置，==1未配置
				    {

				    	runEn=1;

					    eepromReadBytes(EE_MEASURE_INTERVAL,eepread,2);
					    intervTime=eepread[1];
					    intervTime<<=8;
					    intervTime+=eepread[0];//得到间隔时间

					    eepromReadBytes(EE_HIGHBIN_TEM_TRIP_POINT,eepread,2);
					    hiTBinTrpot=eepread[1];
					    hiTBinTrpot<<=8;
					    hiTBinTrpot+=eepread[0];//得到高温报警点
					    eepromReadBytes(EE_HIGHBIN_F_COUNTER,eepread,2);
					    hiFuncCount=eepread[1];
					    hiFuncCount<<=8;
					    hiFuncCount+=eepread[0];//得到触发高温报警的计数器
					    eepromReadBytes(EE_HIGH_FUNC_LIMIT,eepread,2);
					    hiFuncLimit=eepread[1];
					    hiFuncLimit<<=8;
					    hiFuncLimit+=eepread[0];//得到高温报警触发极限值

					    eepromReadBytes(EE_LOWBIN_TEM_TRIP_POINT,eepread,2);
					    lowTBinTrpot=eepread[1];
					    lowTBinTrpot<<=8;
					    lowTBinTrpot+=eepread[0];//得到低温报警点
					    eepromReadBytes(EE_LOWBIN_F_COUNTER,eepread,2);
					    lowFuncCount=eepread[1];
					    lowFuncCount<<=8;
					    lowFuncCount+=eepread[0];//得到触发低温报警的计数器
					    eepromReadBytes(EE_LOW_FUNC_LIMIT,eepread,2);
					    lowFuncLimit=eepread[1];
					    lowFuncLimit<<=8;
					    lowFuncLimit+=eepread[0];//得到低温报警触发极限值


				   }


			    }
			    START_END:
			}
			if(key_stop)//停止键
			{
               /*
				if ( STATUS_NG == setPwg2ModeAuto() ) {
				    //asm("brk");
					//break;
				}
				// Get PWG2 mode.
				//modeAuto = getPwg2Mode();

				startClgIOSC();
				status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
                */
				key_stop=0;
				if(runEn==1)
				{
					runEn=0;
					OnOffSingleDisp(0x1A,0);//关闭太阳图标
					OnOffSingleDisp(0x9D,1);//显示停止图标
				}
			}
			if(runEn)
			{


				if(timeCount>=intervTime)
				{
                    /*
					if ( STATUS_NG == setPwg2ModeAuto() ) {
						//asm("brk");
						//break;
					}
					// Get PWG2 mode.
					//modeAuto = getPwg2Mode();

					startClgIOSC();
					status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
                    */

					timeCount=0;

					/*
					RfcCount = 0;
					status = runRfcConvertingOperation( (unsigned long)0x00FFD8F0 , &RfcCount );//耗时270ms
					if ( status == RFC_STS_CONV_SEN_A )
					{
						//RfcTempVal=RfcTempVal;
						fltData=getTemp(RfcCount);
						dispDigital(fltData,2);

						if(fltData>hiTBinTrpot)
						{
							OnOffSingleDisp(0x1A,0);//关闭太阳图标
							OnOffSingleDisp(0x2B,1);//显示HI图标
							OnOffSingleDisp(0x9D,1);//显示停止图标
							runEn=0;
						}
						if(fltData<lowTBinTrpot)
						{
							OnOffSingleDisp(0x1A,0);//关闭太阳图标
							OnOffSingleDisp(0x3B,1);//显示LOW图标
							OnOffSingleDisp(0x9D,1);//显示停止图标
							runEn=0;
						}
					}
					*/
					setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );
					SHTW2ReadData(i2cRevDate,6);
					tempData=i2cRevDate[3];//先获得温度高字节
					tempData<<=8;
					tempData+=i2cRevDate[4];//加上温度低字节
					fltData=-45+(175*(float)tempData/65536);
					dispDigital(fltData,2);
					setPortOutputP4x( PORT_NO_PX3, PORT_DATA_LOW );
					if(fltData>hiTBinTrpot)
					{
						OnOffSingleDisp(0x1A,0);//关闭太阳图标
						OnOffSingleDisp(0x2B,1);//显示HI图标
						OnOffSingleDisp(0x9D,1);//显示停止图标
						runEn=0;
					}
					if(fltData<lowTBinTrpot)
					{
						OnOffSingleDisp(0x1A,0);//关闭太阳图标
						OnOffSingleDisp(0x3B,1);//显示LOW图标
						OnOffSingleDisp(0x9D,1);//显示停止图标
						runEn=0;
					}
				}



			}
            //*/

			/*
			//setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );
			//status = eepromWriteBytes(1,eepwite,1);
			eepromWriteOneByOne(38,eepwite,4);
			status = eepromReadBytes(38,eepread,4);
			setPortOutputP4x( PORT_NO_PX3, PORT_DATA_LOW );
			*/


			/*
			restop:
			modeSuperEconomy = getPwg2Mode();
			if(modeSuperEconomy!=5)
			{
				status = switchClgSystemClockOSC1();
				stopClgIOSC();
				if ( STATUS_NG == setPwg2ModeSuperEconomy() ) {
				    asm("nop");
				    goto restop;
				}
			}

			// Get PWG2 mode.
			//modeSuperEconomy = getPwg2Mode();
			asm("halt");
			asm("nop");



			//asm ( "slp" );
			//asm ( "nop" );
			//disableRtca1SecTimer();


		    if(timeCount>=5)
		    {
		    	timeCount=0;
		    	if ( STATUS_NG == setPwg2ModeAuto() ) {
		    		//asm("brk");
		    		//break;
		    	}
		    	// Get PWG2 mode.
		    	//modeAuto = getPwg2Mode();

		    	startClgIOSC();
		    	status = switchClgSystemClockIOSC();			// The system clock is set in OSC3.
		    	//timeCount=30000;
		    	//timeCount=500;

		        //RfcCount = 0;
		        //status = runRfcConvertingOperation( (unsigned long)0x00FFD8F0 , &RfcCount );//耗时270ms
		        //if ( status == RFC_STS_CONV_SEN_A )
		        //{
		    	//    //RfcTempVal=RfcTempVal;
		    	 //   fltData=getTemp(RfcCount);
		    	 //   dispDigital(fltData,2);
		        //}


		    	setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );
		    	SHTW2ReadData(i2cRevDate,6);
		    	tempData=i2cRevDate[3];//先获得温度高字节
		    	tempData<<=8;
		    	tempData+=i2cRevDate[4];//加上温度低字节
		    	fltData=-45+(175*(float)tempData/65536);
		    	dispDigital(fltData,2);
		    	setPortOutputP4x( PORT_NO_PX3, PORT_DATA_LOW );
		    }


			//delay_ms(100);
			*/


		    /*
		    //setPortOutputP4x( PORT_NO_PX3, PORT_DATA_HIGH );
		    Seconds=rtc_getSeconds();

		    status = eepromWriteBytes(0,eepwite,4);
		    status = eepromReadBytes(0,eepread,4);
		    //SHTW2ReadData(i2cRevDate,6);
		    */


		    /*status = sendUartData( dispAddData, 7 );
		    	if ( status != STATUS_OK ) {
		    		asm("brk");
		    		return STATUS_NG;
		    	}*/
		/// Set LCD Normal Display

			//LCD8DSP_DSPC = (LCD8DSP_DSPC & 0xfc) | 1;
		    //SetLcd8bDisplay1Seg(LCD_SEG19,0,1);

			//delay_ms(500);

			//SetLcd8bDisplay1Seg(LCD_SEG19,0,0);*/

		    //LcdDisplayChar(dispAddData,7,NULL,0);
		    //SetLcd8bDisplay1Seg(LCD_5B_SEG,LCD_5B_COM,1);

		    //dispDigital(-138.1,1);

		    //setPortOutputP4x( PORT_NO_PX2, PORT_DATA_LOW );
			//delay_ms(500);

		    //while(timeCount>0);//10MS定时
/*
			i2cSendDate[0]=0X5C;i2cSendDate[1]=0X24;
			status = sendI2cMstData( ADDRES_SHTW2, i2cSendDate, 2 );
			if ( status != I2C_MST_STS_OK )
			{
				/// Stop I2C.
				stopI2cMst();
			}
			delay_ms(20);
			/// Receive data.
			status = receiveI2cMstData( ADDRES_SHTW2, i2cRevDate, 6 );

			/// Check on receive result.
			if ( status != I2C_MST_STS_OK )
			{
				/// Stop I2C.
				stopI2cMst();
			}
*/

	}

	return STATUS_OK;
}
void delay_ms(int time)
{
	int i,j;
	for(i=time;i>0;i--)
	{
		for(j=120;j>0;j--);
	}

}
void cleanDateBuf(uchar *data,uchar len)
{
	int i;
	for(i=0;i<len;i++)
	{
		data[i]=0;
	}
}
